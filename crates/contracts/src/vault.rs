//! Module containing utilities for interfacing with the Balancer V2 Vault
//! contract.

use {
    crate::{BalancerV2Vault, alloy::BalancerV2Authorizer},
    alloy::primitives::Address,
    ethcontract::{Bytes, H160, common::FunctionExt as _, web3::signing},
};

fn role_id(target: H160, function_name: &str) -> Bytes<[u8; 32]> {
    let function = match BalancerV2Vault::raw_contract()
        .interface
        .abi
        .function(function_name)
    {
        Ok(function) => function,
        Err(_) => return Bytes([0u8; 32]),
    };

    let mut data = [0u8; 36];
    data[12..32].copy_from_slice(&target.0);
    data[32..36].copy_from_slice(&function.selector());
    Bytes(signing::keccak256(&data))
}

pub async fn grant_required_roles(
    authorizer: &BalancerV2Authorizer::Instance,
    vault: H160,
    vault_relayer: H160,
) -> Result<(), alloy::contract::Error> {
    authorizer
        .grantRoles(
            vec![
                role_id(vault, "manageUserBalance").0.into(),
                role_id(vault, "batchSwap").0.into(),
            ],
            Address::from(vault_relayer.0),
        )
        .send()
        .await?
        .watch()
        .await?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use {super::*, ethcontract::H256};

    #[test]
    fn role_ids() {
        // These roles were generated by simulating `manageUserBalance` and
        // `batchSwap` transactions in Tenderly and then inspecting the `role`
        // value that was passed to the authenticator contract.

        let vault = BalancerV2Vault::raw_contract().networks["1"].address;
        assert_eq!(
            role_id(vault, "manageUserBalance"),
            Bytes(
                "0xeba777d811cd36c06d540d7ff2ed18ed042fd67bbf7c9afcf88c818c7ee6b498"
                    .parse::<H256>()
                    .unwrap()
                    .0
            )
        );
        assert_eq!(
            role_id(vault, "batchSwap"),
            Bytes(
                "0x1282ab709b2b70070f829c46bc36f76b32ad4989fecb2fcb09a1b3ce00bbfc30"
                    .parse::<H256>()
                    .unwrap()
                    .0
            )
        );
    }
}
