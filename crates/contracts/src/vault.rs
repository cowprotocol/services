//! Module containing utilities for interfacing with the Balancer V2 Vault
//! contract.

use {
    crate::alloy::BalancerV2Authorizer,
    alloy::{primitives::Address, sol_types::SolCall},
};

fn role_id<Call: SolCall>(vault: Address) -> alloy::primitives::B256 {
    let mut data = [0u8; 36];
    data[12..32].copy_from_slice(vault.as_slice());
    data[32..36].copy_from_slice(&Call::SELECTOR);
    alloy::primitives::keccak256(data)
}

pub async fn grant_required_roles(
    authorizer: &BalancerV2Authorizer::Instance,
    vault: Address,
    vault_relayer: Address,
) -> Result<(), alloy::contract::Error> {
    use crate::alloy::BalancerV2Vault::BalancerV2Vault::batchSwapCall;
    use crate::alloy::BalancerV2Vault::BalancerV2Vault::manageUserBalanceCall;

    authorizer
        .grantRoles(
            vec![
                role_id::<manageUserBalanceCall>(vault).0.into(),
                role_id::<batchSwapCall>(vault).0.into(),
            ],
            vault_relayer,
        )
        .send()
        .await?
        .watch()
        .await?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use alloy::primitives::b256;

    use super::*;
    use crate::alloy::BalancerV2Vault;
    use crate::alloy::BalancerV2Vault::BalancerV2Vault::batchSwapCall;
    use crate::alloy::BalancerV2Vault::BalancerV2Vault::manageUserBalanceCall;

    #[test]
    fn role_ids() {
        // These roles were generated by simulating `manageUserBalance` and
        // `batchSwap` transactions in Tenderly and then inspecting the `role`
        // value that was passed to the authenticator contract.

        let vault = BalancerV2Vault::deployment_address(&1).unwrap();
        assert_eq!(
            role_id::<manageUserBalanceCall>(vault),
            b256!("0xeba777d811cd36c06d540d7ff2ed18ed042fd67bbf7c9afcf88c818c7ee6b498")
        );
        assert_eq!(
            role_id::<batchSwapCall>(vault),
            b256!("0x1282ab709b2b70070f829c46bc36f76b32ad4989fecb2fcb09a1b3ce00bbfc30")
        );
    }
}
