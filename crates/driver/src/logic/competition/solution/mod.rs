use {
    super::auction::Auction,
    crate::{
        logic::eth,
        solver::{self, Solver},
        EthNode,
        Simulator,
    },
    primitive_types::{H160, U256},
    std::collections::HashMap,
};

mod approvals;
pub mod settlement;

pub use {
    approvals::Approvals,
    settlement::{Score, Settlement},
};

/// A solution represents a set of orders which the solver has found an optimal
/// way to settle. A [`Solution`] is generated by a solver as a response to a
/// [`super::auction::Auction`].
#[derive(Debug, Clone)]
pub struct Solution {
    pub prices: HashMap<H160, U256>,
    pub approvals: Approvals,
}

impl Solution {
    fn tx(&self) -> eth::Tx {
        todo!()
    }
}

/// Solve an auction and return the [`Score`] of the solution.
pub async fn solve(
    solver: &Solver,
    simulator: &Simulator,
    node: &EthNode,
    auction: Auction,
) -> Result<Score, solver::Error> {
    let solution = solver.solve(auction).await?;
    Ok(score(simulator, node, &solution).await)
}

/// Calculate the score of a solution.
async fn score(simulator: &Simulator, node: &EthNode, solution: &Solution) -> Score {
    // TODO So in order to calculate the objective value, it seems the algorithm
    // needs to know the prices of all tokens with ExternalPrices. I need to figure
    // out how that type works and when the values are calculated, etc.
    // ExternalPrices is built from the prices passed in as part of the auction,
    // Auction::prices.
    todo!()
}

/// A unique solution ID. TODO Once this is finally decided, document what this
/// ID is used for.
#[derive(Debug, Clone, Copy)]
pub struct Id(pub u64);
