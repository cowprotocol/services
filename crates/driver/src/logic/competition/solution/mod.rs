use {
    crate::{
        blockchain,
        boundary,
        logic::{
            competition::{self, order},
            eth,
        },
        simulator,
        solver::{self, Solver},
        Ethereum,
        Simulator,
    },
    futures::future::try_join_all,
    itertools::Itertools,
    num::ToPrimitive,
    primitive_types::U256,
    std::collections::HashMap,
};

pub mod interaction;
mod settlement;
pub mod trade;

pub use {interaction::Interaction, settlement::Settlement, trade::Trade};

/// A solution represents a set of orders which the solver has found an optimal
/// way to settle. A [`Solution`] is generated by a solver as a response to a
/// [`super::auction::Auction`].
#[derive(Debug)]
pub struct Solution {
    /// Trades settled by this solution.
    pub trades: Vec<Trade>,
    /// Token prices for this solution.
    pub prices: HashMap<eth::TokenAddress, competition::Price>,
    /// List of interactions with smart contracts needed to execute this
    /// solution on the blockchain.
    pub interactions: Vec<Interaction>,
}

impl Solution {
    pub async fn approvals(
        &self,
        eth: &Ethereum,
    ) -> Result<impl Iterator<Item = eth::allowance::Approval>, blockchain::Error> {
        let settlement_contract = &eth.contracts().settlement();
        let allowances = try_join_all(self.allowances().map(|required| async move {
            eth.allowance(settlement_contract.address().into(), required.0.spender)
                .await
                .map(|existing| (required, existing))
        }))
        .await?;
        let approvals = allowances.into_iter().filter_map(|(required, existing)| {
            required
                .approval(&existing)
                // As a gas optimization, we always approve the max amount possible. This minimizes
                // the number of approvals necessary, and therefore minimizes the approval fees over time. This is a
                // potential security issue, but its effects are minimized and only exploitable if
                // solvers use insecure contracts.
                .map(eth::allowance::Approval::max)
        });
        Ok(approvals)
    }

    /// Return the trades which fulfill non-liquidity auction orders. These are
    /// the orders placed by end-users.
    pub fn user_trades(&self) -> impl Iterator<Item = &trade::Fulfillment> {
        self.trades.iter().filter_map(|trade| match trade {
            Trade::Fulfillment(fulfillment) => match fulfillment.order.kind {
                order::Kind::Market | order::Kind::Limit { .. } => Some(fulfillment),
                order::Kind::Liquidity => None,
            },
            Trade::Jit(_) => None,
        })
    }

    /// Return the allowances in a normalized form, where there is only one
    /// allowance per [`eth::allowance::Spender`], and they're ordered
    /// deterministically.
    fn allowances(&self) -> impl Iterator<Item = eth::allowance::Required> {
        let mut normalized = HashMap::new();
        let allowances = self
            .interactions
            .iter()
            .flat_map(|interaction| match interaction {
                Interaction::Custom(interaction) => interaction.allowances.clone().into_iter(),
                Interaction::Liquidity(interaction) => vec![eth::Allowance {
                    spender: eth::allowance::Spender {
                        // TODO This is a mistake, right? I think this should be the settlement
                        // contract address?
                        address: interaction.liquidity.address,
                        token: interaction.output.token,
                    },
                    amount: interaction.output.amount,
                }
                .into()]
                .into_iter(),
            });
        for allowance in allowances {
            let amount = normalized
                .entry(allowance.0.spender)
                .or_insert(U256::zero());
            *amount = amount.saturating_add(allowance.0.amount);
        }
        normalized
            .into_iter()
            .map(|(spender, amount)| eth::Allowance { spender, amount }.into())
            .sorted()
    }
}

/// The solution score. This is often referred to as the "objective value".
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]
pub struct Score(pub num::BigRational);

impl From<Score> for f64 {
    fn from(score: Score) -> Self {
        score.0.to_f64().expect("value can be represented as f64")
    }
}

impl From<num::BigRational> for Score {
    fn from(inner: num::BigRational) -> Self {
        Self(inner)
    }
}

/// Solve an auction and return the [`Score`] of the solution.
pub async fn solve(
    solver: &Solver,
    eth: &Ethereum,
    simulator: &Simulator,
    auction: &competition::Auction,
) -> Result<Score, Error> {
    let solution = solver.solve(auction).await?;
    let simulation = simulator.simulate(&solution).await?;
    let settlement = Settlement::encode(solver, eth, auction, &solution).await?;
    settlement
        .score(eth, auction, simulation.gas)
        .await
        .map_err(Into::into)
}

/// A unique solution ID. TODO Once this is finally decided, document what this
/// ID is used for.
#[derive(Debug, Clone, Copy)]
pub struct Id(pub u64);

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("solver error: {0:?}")]
    Solver(#[from] solver::Error),
    #[error("simulation error: {0:?}")]
    Simulation(#[from] simulator::Error),
    #[error("boundary error: {0:?}")]
    Boundary(#[from] boundary::Error),
}
