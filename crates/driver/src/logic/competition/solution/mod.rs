use {
    super::auction::Auction,
    crate::{
        solver::{self, Solver},
        Ethereum,
        Simulator,
    },
    primitive_types::{H160, U256},
    std::collections::HashMap,
};

mod allowances;
pub mod settlement;

pub use {
    allowances::Allowances,
    settlement::{Score, Settlement},
};

/// A solution represents a set of orders which the solver has found an optimal
/// way to settle. A [`Solution`] is generated by a solver as a response to a
/// [`super::auction::Auction`].
#[derive(Debug)]
pub struct Solution {
    pub prices: HashMap<H160, U256>,
    pub allowances: Allowances,
}

/// Solve an auction and return the [`Score`] of the solution.
pub async fn solve(
    solver: &Solver,
    eth: &Ethereum,
    simulator: &Simulator,
    auction: &Auction,
) -> Result<Score, solver::Error> {
    let solution = solver.solve(auction).await?;
    let settlement = Settlement::encode(eth, auction, solution).await;
    Ok(settlement.score(simulator))
}

/// A unique solution ID. TODO Once this is finally decided, document what this
/// ID is used for.
#[derive(Debug, Clone, Copy)]
pub struct Id(pub u64);
