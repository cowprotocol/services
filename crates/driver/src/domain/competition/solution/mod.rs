use {
    crate::{
        boundary,
        domain::{
            competition::{self, order},
            eth,
        },
        infra::{
            self,
            blockchain::{self, Ethereum},
            simulator,
            solver::Solver,
            time,
            Simulator,
        },
        util,
    },
    bigdecimal::Signed,
    futures::future::try_join_all,
    itertools::Itertools,
    num::ToPrimitive,
    settlement::Settlement,
    std::collections::HashMap,
};

pub mod interaction;
pub mod settlement;
pub mod trade;

pub use {interaction::Interaction, trade::Trade};

/// A solution represents a set of orders which the solver has found an optimal
/// way to settle. A [`Solution`] is generated by a solver as a response to a
/// [`super::auction::Auction`].
#[derive(Debug, Clone)]
pub struct Solution {
    pub id: Id,
    /// Trades settled by this solution.
    pub trades: Vec<Trade>,
    pub prices: ClearingPrices,
    pub interactions: Vec<Interaction>,
    pub weth: eth::WethAddress,
    /// The solver which generated this solution.
    pub solver: Solver,
}

impl Solution {
    /// Approval interactions necessary for encoding the settlement.
    pub async fn approvals(
        &self,
        eth: &Ethereum,
    ) -> Result<impl Iterator<Item = eth::allowance::Approval>, Error> {
        let settlement_contract = &eth.contracts().settlement();
        let allowances = try_join_all(self.allowances().map(|required| async move {
            eth.allowance(settlement_contract.address().into(), required.0.spender)
                .await
                .map(|existing| (required, existing))
        }))
        .await?;
        let approvals = allowances.into_iter().filter_map(|(required, existing)| {
            required
                .approval(&existing)
                // As a gas optimization, we always approve the max amount possible. This minimizes
                // the number of approvals necessary, and therefore minimizes the approval fees over time. This is a
                // potential security issue, but its effects are minimized and only exploitable if
                // solvers use insecure contracts.
                .map(eth::allowance::Approval::max)
        });
        Ok(approvals)
    }

    /// An empty solution has no user trades and a score of 0.
    pub fn is_empty(&self) -> bool {
        self.user_trades().next().is_none()
    }

    /// Return the trades which fulfill non-liquidity auction orders. These are
    /// the orders placed by end users.
    fn user_trades(&self) -> impl Iterator<Item = &trade::Fulfillment> {
        self.trades.iter().filter_map(|trade| match trade {
            Trade::Fulfillment(fulfillment) => match fulfillment.order().kind {
                order::Kind::Market | order::Kind::Limit { .. } => Some(fulfillment),
                order::Kind::Liquidity => None,
            },
            Trade::Jit(_) => None,
        })
    }

    /// Return the allowances in a normalized form, where there is only one
    /// allowance per [`eth::allowance::Spender`], and they're ordered
    /// deterministically.
    fn allowances(&self) -> impl Iterator<Item = eth::allowance::Required> {
        let mut normalized = HashMap::new();
        // TODO: we need to carry the "internalize" flag with the allowances,
        // since we don't want to include approvals for interactions that are
        // meant to be internalized anyway.
        let allowances = self.interactions.iter().flat_map(Interaction::allowances);
        for allowance in allowances {
            let amount = normalized
                .entry(allowance.0.spender)
                .or_insert(eth::U256::zero());
            *amount = amount.saturating_add(allowance.0.amount);
        }
        normalized
            .into_iter()
            .map(|(spender, amount)| eth::Allowance { spender, amount }.into())
            .sorted()
    }

    /// Verify that the solution is valid and can be broadcast safely. See
    /// [`settlement::Verified`].
    pub async fn verify(
        self,
        eth: &Ethereum,
        simulator: &Simulator,
        auction: &competition::Auction,
    ) -> Result<settlement::Verified, Error> {
        self.verify_asset_flow()?;
        self.verify_internalization(auction)?;

        let (settlement, access_list, gas) = self
            .simulate(eth, simulator, auction, settlement::Internalization::Enable)
            .await?;

        // Ensure that the solver account has enough Ether balance to mine the
        // transaction. Simulations failing on insufficient gas is not
        // guaranteed by all nodes.
        let balance = eth.balance(self.solver.address()).await?;
        if balance < gas.required_balance() {
            return Err(Error::InsufficientBalance);
        }

        // Some rules which are enforced by the settlement contract for non-internalized
        // interactions are not enforced for internalized interactions (in order to save
        // gas). However, publishing a settlement with interactions that violate
        // these rules constitutes a punishable offense for the solver, even if
        // the interactions are internalized. To ensure that this doesn't happen, check
        // that the settlement simulates even when internalizations are disabled.
        if self
            .interactions
            .iter()
            .any(|interaction| interaction.internalize())
        {
            self.simulate(
                eth,
                simulator,
                auction,
                settlement::Internalization::Disable,
            )
            .await
            .map_err(|_| VerificationError::FailingInternalization)?;
        }

        Ok(settlement::Verified {
            inner: settlement,
            solution: self,
            access_list,
            gas,
        })
    }

    /// Simulate settling this solution on the blockchain. This process
    /// generates the access list and estimates the gas needed to settle
    /// the solution.
    async fn simulate(
        &self,
        eth: &Ethereum,
        simulator: &Simulator,
        auction: &competition::Auction,
        internalization: settlement::Internalization,
    ) -> Result<(Settlement, eth::AccessList, settlement::Gas), Error> {
        // Our settlement contract will fail if the receiver is a smart contract.
        // Because of this, if the receiver is a smart contract and we try to
        // estimate the access list, the access list estimation will also fail.
        //
        // This failure happens because the Ethereum protocol sets a hard gas limit
        // on transferring ETH into a smart contract, which some contracts exceed unless
        // the access list is already specified.

        // The solution is to do access list estimation in two steps: first, simulate
        // moving 1 wei into every smart contract to get a partial access list.
        let partial_access_lists = try_join_all(self.user_trades().map(|trade| async {
            if !trade.order().buys_eth() || !trade.order().pays_to_contract(eth).await? {
                return Ok(Default::default());
            }
            let tx = eth::Tx {
                from: self.solver.address(),
                to: trade.order().receiver(),
                value: 1.into(),
                input: Vec::new(),
                access_list: Default::default(),
            };
            Result::<_, Error>::Ok(simulator.access_list(tx).await?)
        }))
        .await?;
        let partial_access_list = partial_access_lists
            .into_iter()
            .fold(eth::AccessList::default(), |acc, list| acc.merge(list));

        // Encode the settlement with the partial access list.
        let settlement = Settlement::encode(eth, auction, self, internalization).await?;
        let tx = settlement.clone().tx().set_access_list(partial_access_list);

        // Second, simulate the full access list, passing the partial access
        // list into the simulation. This way the settlement contract does not
        // fail, and hence the full access list estimation also does not fail.
        let access_list = simulator.access_list(tx.clone()).await?;
        let tx = tx.set_access_list(access_list.clone());

        // Get the gas parameters for the settlement using the full access list.
        let estimate = simulator.gas(tx).await?;
        let price = eth.gas_price().await?;
        let gas = settlement::Gas::new(estimate, price);

        Ok((settlement, access_list, gas))
    }

    /// Check that the sum of tokens entering the settlement is not less than
    /// the sum of tokens exiting the settlement.
    fn verify_asset_flow(&self) -> Result<(), VerificationError> {
        let mut flow: HashMap<eth::TokenAddress, num::BigInt> = Default::default();

        // Interaction inputs represent flow out of the contract, i.e. negative flow.
        for input in self
            .interactions
            .iter()
            .flat_map(|interaction| interaction.inputs())
        {
            *flow.entry(input.token).or_default() -= util::conv::u256::to_big_int(input.amount);
        }

        // Interaction outputs represent flow into the contract, i.e. positive flow.
        for output in self
            .interactions
            .iter()
            .flat_map(|interaction| interaction.outputs())
        {
            *flow.entry(output.token).or_default() += util::conv::u256::to_big_int(output.amount);
        }

        // For trades, the sold amounts are always entering the contract (positive
        // flow), whereas the bought amounts are always exiting the contract
        // (negative flow).
        for trade in self.trades.iter() {
            let trade::Execution { sell, buy } = trade
                .execution(self)
                .map_err(|_| VerificationError::AssetFlow)?;
            *flow.entry(sell.token).or_default() += util::conv::u256::to_big_int(sell.amount);
            // Within the settlement contract, the orders which buy ETH are wrapped into
            // WETH, and hence contribute to WETH flow.
            *flow.entry(buy.token.wrap(self.weth)).or_default() -=
                util::conv::u256::to_big_int(buy.amount);
        }

        if flow.values().any(|v| v.is_negative()) {
            Err(VerificationError::AssetFlow)
        } else {
            Ok(())
        }
    }

    /// Check that internalized interactions only use trusted tokens.
    fn verify_internalization(
        &self,
        auction: &competition::Auction,
    ) -> Result<(), VerificationError> {
        if self
            .interactions
            .iter()
            .filter(|interaction| interaction.internalize())
            .all(|interaction| {
                interaction
                    .inputs()
                    .iter()
                    .all(|asset| auction.is_trusted(asset.token))
            })
        {
            Ok(())
        } else {
            Err(VerificationError::UntrustedInternalization)
        }
    }

    /// The clearing prices, represented as a list of assets. If there are any
    /// orders which buy ETH, this will contain the correct ETH price.
    pub fn prices(&self) -> Result<Vec<eth::Asset>, Error> {
        let prices = self
            .prices
            .0
            .iter()
            .map(|(&token, &amount)| eth::Asset { token, amount });

        // The solution contains an order which buys ETH. Solvers only produce solutions
        // for ERC20 tokens, while the driver adds special [`Interaction`]s to
        // wrap/unwrap the ETH tokens into WETH, and sends orders to the solver with
        // WETH instead of ETH. Once the driver receives the solution which fulfills an
        // ETH order, a clearing price for ETH needs to be added, equal to the
        // WETH clearing price.
        if self.user_trades().any(|trade| trade.order().buys_eth()) {
            // If no order trades WETH, the WETH price is not necessary, only the ETH
            // price is needed. Remove the unneeded WETH price, which slightly reduces
            // gas used by the settlement.
            let mut prices = if self.user_trades().all(|trade| {
                trade.order().sell.token != self.weth.0 && trade.order().buy.token != self.weth.0
            }) {
                prices
                    .filter(|price| price.token != self.weth.0)
                    .collect_vec()
            } else {
                prices.collect_vec()
            };

            // Add a clearing price for ETH equal to WETH.
            prices.push(eth::Asset {
                token: eth::ETH_TOKEN,
                amount: self
                    .prices
                    .0
                    .get(&self.weth.into())
                    .ok_or(Error::MissingWethClearingPrice)?
                    .to_owned(),
            });

            return Ok(prices);
        }

        // TODO: We should probably filter out all unused prices.

        Ok(prices.collect_vec())
    }

    /// Clearing price for the given token.
    pub fn price(&self, token: eth::TokenAddress) -> Option<eth::U256> {
        // The clearing price of ETH is equal to WETH.
        let token = token.wrap(self.weth);
        self.prices.0.get(&token).map(ToOwned::to_owned)
    }
}

/// Token prices for this solution, expressed using an arbitrary reference
/// unit chosen by the solver. These values are only meaningful in relation
/// to each others.
///
/// The rule which relates two prices for tokens X and Y is:
/// ```
/// amount_x * price_x = amount_y * price_y
/// ```
#[derive(Debug, Clone)]
pub struct ClearingPrices(HashMap<eth::TokenAddress, eth::U256>);

impl ClearingPrices {
    pub fn new(prices: HashMap<eth::TokenAddress, eth::U256>) -> Self {
        Self(prices)
    }
}

/// The time allocated for the solver to solve an auction.
#[derive(Debug, Clone, Copy)]
pub struct SolverTimeout(std::time::Duration);

impl From<std::time::Duration> for SolverTimeout {
    fn from(value: std::time::Duration) -> Self {
        Self(value)
    }
}

impl From<SolverTimeout> for std::time::Duration {
    fn from(value: SolverTimeout) -> Self {
        value.0
    }
}

impl SolverTimeout {
    /// The time limit passed to the solver for solving an auction.
    ///
    /// Solvers are given a time limit that's `buffer` less than the specified
    /// deadline. The reason for this is to allow the solver sufficient time to
    /// search for the most optimal solution, but still ensure there is time
    /// left for the driver to do some other necessary work and forward the
    /// results back to the protocol.
    pub fn new(
        deadline: chrono::DateTime<chrono::Utc>,
        buffer: chrono::Duration,
        now: time::Now,
    ) -> Option<SolverTimeout> {
        let deadline = deadline - now.now() - buffer;
        deadline.to_std().map(Self).ok()
    }

    pub fn deadline(self, now: infra::time::Now) -> chrono::DateTime<chrono::Utc> {
        now.now() + chrono::Duration::from_std(self.0).expect("reasonable solver timeout")
    }
}

/// The solution score. This is often referred to as the "objective value".
#[derive(Debug, Default, PartialEq, Eq, PartialOrd, Ord, Clone)]
pub struct Score(pub num::BigRational);

impl From<Score> for f64 {
    fn from(score: Score) -> Self {
        score.0.to_f64().expect("value can be represented as f64")
    }
}

impl From<num::BigRational> for Score {
    fn from(inner: num::BigRational) -> Self {
        Self(inner)
    }
}

impl Score {
    pub fn zero() -> Self {
        Self::default()
    }
}

/// A unique solution ID. This ID is generated by the solver and only needs to
/// be unique within a single round of competition. This ID is only important in
/// the communication between the driver and the solver, and it is not used by
/// the protocol.
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct Id(pub u64);

impl From<u64> for Id {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl From<Id> for u64 {
    fn from(value: Id) -> Self {
        value.0
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("blockchain error: {0:?}")]
    Blockchain(#[from] blockchain::Error),
    #[error("boundary error: {0:?}")]
    Boundary(#[from] boundary::Error),
    #[error("verification error: {0:?}")]
    Verification(#[from] VerificationError),
    #[error("missing weth clearing price")]
    MissingWethClearingPrice,
    #[error("insufficient solver account Ether balance")]
    InsufficientBalance,
}

/// Solution verification failed.
#[derive(Debug, thiserror::Error)]
#[error("verification error")]
pub enum VerificationError {
    #[error("simulation error: {0:?}")]
    Simulation(#[from] simulator::Error),
    #[error(
        "invalid asset flow: token amounts entering the settlement do not equal token amounts \
         exiting the settlement"
    )]
    AssetFlow,
    #[error(
        "invalid internalization: solution attempts to internalize tokens which are not trusted"
    )]
    UntrustedInternalization,
    #[error("invalid internalization: uninternalized solution fails to simulate")]
    FailingInternalization,
}

impl From<simulator::Error> for Error {
    fn from(value: simulator::Error) -> Self {
        VerificationError::from(value).into()
    }
}
