use {
    crate::{
        boundary,
        infra::{
            blockchain::Ethereum,
            mempool,
            solver::{self, Solver},
            time,
            Mempool,
            Simulator,
        },
    },
    dashmap::DashMap,
    std::sync::Arc,
};

pub mod auction;
pub mod order;
pub mod quote;
pub mod solution;

pub use {
    auction::Auction,
    order::Order,
    quote::Quote,
    solution::{Score, Solution, SolverTimeout},
};

/// A ongoing competition. There is one competition going on per solver at any
/// time. The competition stores settlements to solutions generated by the
/// driver, and allows them to be executed as requested later. The settlements
/// expire after a certain amount of time, at which point trying to use them
/// will return an `[Error::SolutionNotFound]`.
#[derive(Debug)]
pub struct Competition {
    pub solver: Solver,
    pub eth: Ethereum,
    pub simulator: Simulator,
    pub now: time::Now,
    pub mempool: Mempool,
    pub settlements: Arc<DashMap<solution::Id, solution::Settlement>>,
}

impl Competition {
    /// Solve an auction as part of this competition.
    pub async fn solve(&self, auction: &Auction) -> Result<(solution::Id, solution::Score), Error> {
        let timeout = SolverTimeout::for_solving(auction.deadline, self.now)?;
        let solution = self.solver.solve(auction, timeout).await?;
        // TODO(#1009) Keep in mind that the driver needs to make sure that the solution
        // doesn't fail simulation. Currently this is the case, but this needs to stay
        // the same as this code changes.
        let gas = solution
            .simulate(&self.eth, &self.simulator, auction)
            .await?;
        let settlement = solution::Settlement::encode(&self.eth, auction, &solution).await?;
        let score = settlement.score(&self.eth, auction, gas).await?;
        let solution_id = solution::Id::random();
        self.settlements.insert(solution_id, settlement);
        // Remove the settlement after it's expired.
        let settlements = Arc::clone(&self.settlements);
        tokio::spawn(async move {
            tokio::time::sleep(Self::expiration_time()).await;
            settlements.remove(&solution_id);
        });
        Ok((solution_id, score))
    }

    /// Execute a solution generated as part of this competition.
    pub async fn execute(&self, solution_id: solution::Id) -> Result<(), Error> {
        let (_, settlement) = self
            .settlements
            .remove(&solution_id)
            .ok_or(Error::SolutionNotFound)?;
        // TODO When this fails, re-insert the settlement
        self.mempool.send(settlement.tx()).await.map_err(Into::into)
    }

    fn expiration_time() -> std::time::Duration {
        std::time::Duration::from_secs(60 * 60)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("no solution found for given id")]
    SolutionNotFound,
    #[error("solution error: {0:?}")]
    Solution(#[from] solution::Error),
    #[error("mempool error: {0:?}")]
    Mempool(#[from] mempool::Error),
    #[error("boundary error: {0:?}")]
    Boundary(#[from] boundary::Error),
    #[error("{0:?}")]
    DeadlineExceeded(#[from] auction::DeadlineExceeded),
    #[error("solver error: {0:?}")]
    Solver(#[from] solver::Error),
}
