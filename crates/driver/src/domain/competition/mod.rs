use {
    crate::{
        boundary,
        infra::{blockchain::Ethereum, mempool, solver::Solver, time, Mempool, Simulator},
    },
    dashmap::DashMap,
    std::sync::Arc,
};

pub mod auction;
pub mod order;
pub mod quote;
pub mod solution;

pub use {
    auction::Auction,
    order::Order,
    quote::Quote,
    solution::{solve, Score, Solution, SolverTimeout},
};

/// A ongoing competition. There is one competition going on per solver at any
/// time. The competition stores settlements to solutions generated by the
/// driver, and allows them to be executed as requested later. The settlements
/// expire after a certain amount of time, at which point trying to use them
/// will return an `[Error::SolutionNotFound]`.
#[derive(Debug)]
pub struct Competition {
    pub solver: Solver,
    pub eth: Ethereum,
    pub simulator: Simulator,
    pub now: time::Now,
    pub mempool: Mempool,
    pub settlements: Settlements,
}

// TODO Remove this, it's not worth having a separate abstraction for this.
#[derive(Debug, Default)]
pub struct Settlements(Arc<DashMap<solution::Id, solution::Settlement>>);

impl Competition {
    /// Solve an auction as part of this competition.
    pub async fn solve(&self, auction: &Auction) -> Result<(solution::Id, solution::Score), Error> {
        let (solution, score) =
            solution::solve(&self.solver, &self.eth, &self.simulator, self.now, auction).await?;
        let id = solution::Id::random();
        let settlement = solution::Settlement::encode(&self.eth, auction, &solution).await?;
        self.settlements.insert(id, settlement);
        Ok((id, score))
    }

    /// Execute a solution generated as part of this competition.
    pub async fn execute(&self, solution_id: solution::Id) -> Result<(), Error> {
        let settlement = self
            .settlements
            .take(solution_id)
            .ok_or(Error::SolutionNotFound)?;
        // TODO When this fails, re-insert the settlement
        self.mempool.send(settlement.tx()).await.map_err(Into::into)
    }
}

impl Settlements {
    fn insert(&self, solution_id: solution::Id, settlement: solution::Settlement) {
        self.0.insert(solution_id, settlement);
        // Remove the settlement after it's expired.
        let settlements = Arc::clone(&self.0);
        tokio::spawn(async move {
            tokio::time::sleep(Self::expiration_time()).await;
            settlements.remove(&solution_id);
        });
    }

    fn take(&self, solution_id: solution::Id) -> Option<solution::Settlement> {
        self.0
            .remove(&solution_id)
            .map(|(_, settlement)| settlement)
    }

    fn expiration_time() -> std::time::Duration {
        std::time::Duration::from_secs(60 * 60)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("no solution found for given id")]
    SolutionNotFound,
    #[error("solution error: {0:?}")]
    Solution(#[from] solution::Error),
    #[error("mempool error: {0:?}")]
    Mempool(#[from] mempool::Error),
    #[error("boundary error: {0:?}")]
    Boundary(#[from] boundary::Error),
}
