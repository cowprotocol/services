use {
    crate::{
        boundary,
        infra::{blockchain::Ethereum, mempool, solver::Solver, time, Mempool, Simulator},
    },
    dashmap::DashMap,
    std::sync::Arc,
};

pub mod auction;
pub mod order;
pub mod quote;
pub mod solution;

pub use {
    auction::Auction,
    order::Order,
    quote::Quote,
    solution::{solve, Score, Solution, SolverTimeout},
};

/// A ongoing competition. There is one competition going on per solver at any
/// time. The competition stores historical solutions generated by the driver,
/// and allows them to be executed as requested later.
#[derive(Debug)]
pub struct Competition {
    solver: Solver,
    eth: Ethereum,
    simulator: Simulator,
    now: time::Now,
    mempool: Mempool,
    settlements: Arc<DashMap<solution::Id, solution::Settlement>>,
}

impl Competition {
    /// Solve an auction as part of this competition.
    pub async fn solve(&self, auction: &Auction) -> Result<(solution::Score, solution::Id), Error> {
        let (solution, score) =
            solution::solve(&self.solver, &self.eth, &self.simulator, self.now, auction).await?;
        let id = solution::Id::random();
        let settlement = solution::Settlement::encode(&self.eth, auction, &solution).await?;
        self.settlements.insert(id, settlement);
        // Remove the settlement after it's expired.
        let solutions = Arc::clone(&self.settlements);
        tokio::spawn(async move {
            tokio::time::sleep(Self::expiration_time()).await;
            solutions.remove(&id);
        });
        Ok((score, id))
    }

    /// Execute a solution generated as part of this competition.
    pub async fn execute(&self, solution_id: solution::Id) -> Result<(), Error> {
        let (_, settlement) = self
            .settlements
            .remove(&solution_id)
            .ok_or(Error::SolutionNotFound)?;
        self.mempool.send(settlement.tx()).await.map_err(Into::into)
    }

    fn expiration_time() -> std::time::Duration {
        std::time::Duration::from_secs(60 * 60)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("no solution found for given id")]
    SolutionNotFound,
    #[error("solution error: {0:?}")]
    Solution(#[from] solution::Error),
    #[error("mempool error: {0:?}")]
    Mempool(#[from] mempool::Error),
    #[error("boundary error: {0:?}")]
    Boundary(#[from] boundary::Error),
}
