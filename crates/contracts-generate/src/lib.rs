use {
    alloy_sol_macro_expander::expand::expand,
    alloy_sol_macro_input::{SolInput, SolInputKind},
    forge_sol_macro_gen::SolMacroGen,
    quote::format_ident,
    std::{
        collections::HashMap,
        fmt::Write,
        path::{Path, PathBuf},
    },
};

pub const MAINNET: u64 = 1;
pub const GNOSIS: u64 = 100;
pub const SEPOLIA: u64 = 11155111;
pub const ARBITRUM_ONE: u64 = 42161;
pub const BASE: u64 = 8453;
pub const POLYGON: u64 = 137;
pub const AVALANCHE: u64 = 43114;
pub const BNB: u64 = 56;
pub const OPTIMISM: u64 = 10;
pub const LENS: u64 = 232;
pub const LINEA: u64 = 59144;
pub const PLASMA: u64 = 9745;

const MOD_HEADER: &'static str = r#"#![allow(unused_imports, unused_attributes, clippy::all, rustdoc::all, non_snake_case)]
    //! This module contains the sol! generated bindings for solidity contracts.
    //! This is autogenerated code.
    //! Do not manually edit these files.
    //! These files may be overwritten by the codegen system at any time.
    "#;

pub struct Module {
    pub contracts: Vec<Contract>,
    submodules: Vec<Submodule>,
}

impl Module {
    pub fn new() -> Self {
        Self {
            contracts: vec![],
            submodules: vec![],
        }
    }

    pub fn add_contract(mut self, contract: Contract) -> Self {
        self.contracts.push(contract);
        self
    }

    pub fn add_submodule(mut self, module: Submodule) -> Self {
        self.submodules.push(module);
        self
    }

    pub fn write_formatted(
        self,
        bindings_folder: &Path,
        all_derives: bool,
        output_folder: &Path,
    ) -> eyre::Result<()> {
        std::fs::create_dir_all(&output_folder)?;

        let mut mod_file = String::from(MOD_HEADER);
        for submodule in self.submodules {
            write_mod_name(&mut mod_file, &submodule.name)?;
            submodule.write_formatted(bindings_folder, all_derives, &output_folder)?;
        }

        for contract in self.contracts {
            let name = contract.name.clone();
            contract.write_formatted(bindings_folder, all_derives, &output_folder)?;
            write_mod_name(&mut mod_file, &name)?;
        }

        let file: syn::File = syn::parse_file(&mod_file)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(output_folder.join("mod.rs"), formatted)?;

        Ok(())
    }
}

pub struct Submodule {
    pub name: String,
    pub contracts: Vec<Contract>,
    submodules: Vec<Submodule>,
}

impl Submodule {
    pub fn new<S: ToString>(name: S) -> Self {
        Self {
            name: name.to_string(),
            contracts: vec![],
            submodules: vec![],
        }
    }

    pub fn add_contract(mut self, contract: Contract) -> Self {
        self.contracts.push(contract);
        self
    }

    pub fn add_submodule(mut self, module: Submodule) -> Self {
        self.submodules.push(module);
        self
    }

    pub fn write_formatted(
        self,
        bindings_folder: &Path,
        all_derives: bool,
        output_folder: &Path,
    ) -> eyre::Result<()> {
        let output_folder = output_folder.join(self.name);
        std::fs::create_dir_all(&output_folder)?;

        let mut mod_file = String::from(MOD_HEADER);
        for submodule in self.submodules {
            write_mod_name(&mut mod_file, &submodule.name)?;
            submodule.write_formatted(bindings_folder, all_derives, &output_folder)?;
        }

        for contract in self.contracts {
            let name = contract.name.clone();
            contract.write_formatted(bindings_folder, all_derives, &output_folder)?;
            write_mod_name(&mut mod_file, &name)?;
        }

        let file: syn::File = syn::parse_file(&mod_file)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(output_folder.join("mod.rs"), formatted)?;

        Ok(())
    }
}

pub struct Contract {
    pub name: String,
    networks: HashMap<u64, (String, Option<u64>)>,
}

impl Contract {
    pub fn new<S: AsRef<str>>(name: S) -> Self {
        Self {
            name: name.as_ref().to_string(),
            networks: HashMap::new(),
        }
    }

    pub fn with_networks<S, I>(mut self, networks: I) -> Self
    where
        S: AsRef<str>,
        I: IntoIterator<Item = (u64, (S, Option<u64>))>,
    {
        for (id, (address, block_number)) in networks.into_iter() {
            self.networks
                .insert(id, (address.as_ref().to_string(), block_number));
        }
        self
    }

    fn bindings_path(&self, bindings_folder: &Path) -> PathBuf {
        bindings_folder.join(&self.name).with_extension("json")
    }

    pub fn generate<P: AsRef<Path>>(
        self,
        bindings_folder: P,
        all_derives: bool,
    ) -> eyre::Result<proc_macro2::TokenStream> {
        let bindings_path = self.bindings_path(bindings_folder.as_ref());
        let mut macrogen = SolMacroGen::new(bindings_path, self.name.clone());
        generate_binding(&mut macrogen, all_derives)?;

        let module_name_ident = format_ident!("{}", self.name);
        let instance_name_ident = format_ident!("{}Instance", self.name);

        let network_entries = self.networks.iter().map(|(id, (address, block_number))| {
            let block_expr = match block_number {
                Some(block) => quote::quote! { Some(#block) },
                None => quote::quote! { None },
            };
            quote::quote! {
                (#id, (::alloy::primitives::address!(#address), #block_expr))
            }
        });

        let instance = quote::quote! {
            pub type Instance = #module_name_ident :: #instance_name_ident<::alloy::providers::DynProvider>;
        };

        let deployment_info = if self.networks.is_empty() {
            proc_macro2::TokenStream::new()
        } else {
            quote::quote! {
                use {
                    std::{
                        sync::LazyLock,
                        collections::HashMap
                    },
                    anyhow::{Result, Context},
                    alloy::{
                        providers::{Provider, DynProvider},
                        primitives::{address, Address},
                    },
                };

                static DEPLOYMENT_INFO: LazyLock<HashMap<u64, (Address, Option<u64>)>> = LazyLock::new(|| {
                    ::std::collections::HashMap::from([
                        #(#network_entries),*
                    ])
                });

                /// Returns the contract's deployment address (if one exists) for the given chain.
                pub fn deployment_address(chain_id: &u64) -> Option<alloy::primitives::Address> {
                    DEPLOYMENT_INFO.get(chain_id).map(|(addr, _)| *addr)
                }

                /// Returns the contract's deployment block (if one exists) for the given chain.
                pub fn deployment_block(chain_id: &u64) -> Option<u64> {
                    DEPLOYMENT_INFO.get(chain_id).map(|(_, block)| *block).flatten()
                }

                impl Instance {
                    pub fn deployed(provider: &DynProvider) -> impl Future<Output = Result<Self>> + Send {
                        async move {
                            let chain_id = provider
                                .get_chain_id()
                                .await
                                .context("could not fetch current chain id")?;

                            let (address, _deployed_block) = *DEPLOYMENT_INFO
                                .get(&chain_id)
                                .with_context(|| format!("no deployment info for chain {chain_id:?}"))?;

                            Ok(Instance::new(
                                address,
                                provider.clone(),
                            ))
                        }
                    }

                    pub fn deployed_block(&self) -> impl Future<Output = Result<Option<u64>>> + Send {
                        async move {
                            let chain_id = self
                                .provider()
                                .get_chain_id()
                                .await
                                .context("could not fetch current chain id")?;
                            if let Some((_address, deployed_block)) = DEPLOYMENT_INFO.get(&chain_id) {
                                return Ok(*deployed_block);
                            }
                            Ok(None)
                        }
                    }
                }
            }
        };

        let mut expansion = macrogen
            .expansion
            .expect("if the expansion failed, it should have errored earlier");
        expansion.extend(instance);
        expansion.extend(deployment_info);

        Ok(expansion)
    }

    pub fn write_formatted<P1, P2>(
        self,
        bindings_folder: P1,
        all_derives: bool,
        output_folder: P2,
    ) -> eyre::Result<()>
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
    {
        let name = self.name.clone();
        let token_stream = self.generate(bindings_folder, all_derives)?;
        let mut buffer = String::new();
        write!(buffer, "{}", token_stream.to_string())?;
        let file: syn::File = syn::parse_file(&buffer)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(
            output_folder.as_ref().join(name).with_extension("rs"),
            formatted,
        )?;
        Ok(())
    }
}

fn generate_binding(instance: &mut SolMacroGen, all_derives: bool) -> eyre::Result<()> {
    let input = instance.get_sol_input()?.normalize_json()?;
    let SolInput {
        attrs: _,
        path: _,
        kind,
    } = input;

    let tokens = match kind {
        SolInputKind::Sol(mut file) => {
            let sol_attr: syn::Attribute = if all_derives {
                syn::parse_quote! {
                        #[sol(rpc, alloy_sol_types = alloy::sol_types, alloy_contract =
                alloy::contract, all_derives = true, extra_derives(serde::Serialize,
                serde::Deserialize))]     }
            } else {
                syn::parse_quote! {
                        #[sol(rpc, alloy_sol_types = alloy::sol_types, alloy_contract =
                alloy::contract)]     }
            };
            file.attrs.push(sol_attr);
            expand(file)?
        }
        _ => unreachable!(),
    };

    instance.expansion = Some(tokens);
    Ok(())
}

fn write_mod_name(contents: &mut String, name: &str) -> eyre::Result<()> {
    if syn::parse_str::<syn::ItemMod>(&format!("pub mod {name};")).is_ok() {
        write!(contents, "pub mod {name};")?;
    } else {
        write!(contents, "pub mod r#{name};")?;
    }
    Ok(())
}

/// Declare a network tuple with an optional block number.
///
/// Example, without blocks:
/// ```no_run
/// networks! {
///     MAINNET => "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
///     SEPOLIA => "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
/// }
/// ```
///
/// Example, with blocks:
/// ```no_run
/// networks! {
///     MAINNET => ("0x9008D19f58AAbD9eD0D60971565AA8510560ab41", 12593265),
///     SEPOLIA => ("0x9008D19f58AAbD9eD0D60971565AA8510560ab41", 4717488),
/// }
/// ```
#[macro_export]
macro_rules! networks {
    // Entry point: accepts a list of entries and delegates to internal rules
    [$(
        $id:expr => $value:tt
    ),* $(,)?] => {
        [$(
            networks!(@entry $id => $value)
        ),*]
    };

    // Internal rule: handle entry with address and block (parenthesized)
    (@entry $id:expr => ($addr:expr, $block:expr)) => {
        ($id, ($addr, Some($block)))
    };

    // Internal rule: handle entry with just address
    (@entry $id:expr => $value:expr) => {
        ($id, ($value, None))
    };
}
