mod sol_macro_gen;

use {
    crate::sol_macro_gen::SolMacroGen,
    alloy_sol_macro_expander::expand::expand,
    alloy_sol_macro_input::{SolInput, SolInputKind},
    quote::{ToTokens, format_ident},
    std::{
        collections::HashMap,
        fmt::Write,
        path::{Path, PathBuf},
    },
};

pub mod networks {
    pub const MAINNET: u64 = 1;
    pub const GNOSIS: u64 = 100;
    pub const SEPOLIA: u64 = 11155111;
    pub const ARBITRUM_ONE: u64 = 42161;
    pub const BASE: u64 = 8453;
    pub const POLYGON: u64 = 137;
    pub const AVALANCHE: u64 = 43114;
    pub const BNB: u64 = 56;
    pub const OPTIMISM: u64 = 10;
    pub const LENS: u64 = 232;
    pub const LINEA: u64 = 59144;
    pub const PLASMA: u64 = 9745;
}

const MOD_HEADER: &str = r#"#![allow(unused_imports, unused_attributes, clippy::all, rustdoc::all, non_snake_case)]
    //! This module contains the sol! generated bindings for solidity contracts.
    //! This is autogenerated code.
    //! Do not manually edit these files.
    //! These files may be overwritten by the codegen system at any time.
    "#;

#[derive(Default)]
pub struct Module {
    pub contracts: Vec<Contract>,
    submodules: Vec<Submodule>,
}

impl Module {
    pub fn add_contract(mut self, contract: Contract) -> Self {
        self.contracts.push(contract);
        self
    }

    pub fn add_submodule(mut self, module: Submodule) -> Self {
        self.submodules.push(module);
        self
    }

    pub fn write_formatted<P1, P2>(
        self,
        bindings_folder: P1,
        all_derives: bool,
        output_folder: P2,
    ) -> anyhow::Result<()>
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
    {
        std::fs::create_dir_all(&output_folder)?;

        let mut mod_file = String::from(MOD_HEADER);
        for submodule in self.submodules {
            write_mod_name(&mut mod_file, &submodule.name)?;
            submodule.write_formatted(bindings_folder.as_ref(), all_derives, &output_folder)?;
        }

        for contract in self.contracts {
            let name = contract.name.clone();
            contract.write_formatted(bindings_folder.as_ref(), all_derives, &output_folder)?;
            write_mod_name(&mut mod_file, &name)?;
        }

        let file: syn::File = syn::parse_file(&mod_file)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(output_folder.as_ref().join("mod.rs"), formatted)?;

        Ok(())
    }
}

pub struct Submodule {
    pub name: String,
    pub contracts: Vec<Contract>,
    submodules: Vec<Submodule>,
}

impl Submodule {
    pub fn new<S: ToString>(name: S) -> Self {
        Self {
            name: name.to_string(),
            contracts: vec![],
            submodules: vec![],
        }
    }

    pub fn add_contract(mut self, contract: Contract) -> Self {
        self.contracts.push(contract);
        self
    }

    pub fn add_submodule(mut self, module: Submodule) -> Self {
        self.submodules.push(module);
        self
    }

    pub fn write_formatted<P1, P2>(
        self,
        bindings_folder: P1,
        all_derives: bool,
        output_folder: P2,
    ) -> anyhow::Result<()>
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
    {
        let output_folder = output_folder.as_ref().join(self.name);
        std::fs::create_dir_all(&output_folder)?;

        let mut mod_file = String::from(MOD_HEADER);
        for submodule in self.submodules {
            write_mod_name(&mut mod_file, &submodule.name)?;
            submodule.write_formatted(bindings_folder.as_ref(), all_derives, &output_folder)?;
        }

        for contract in self.contracts {
            let name = contract.name.clone();
            contract.write_formatted(bindings_folder.as_ref(), all_derives, &output_folder)?;
            write_mod_name(&mut mod_file, &name)?;
        }

        let file: syn::File = syn::parse_file(&mod_file)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(output_folder.join("mod.rs"), formatted)?;

        Ok(())
    }
}

pub struct Contract {
    pub name: String,
    networks: HashMap<u64, (String, Option<u64>)>,
}

impl Contract {
    pub fn new<S: AsRef<str>>(name: S) -> Self {
        Self {
            name: name.as_ref().to_string(),
            networks: HashMap::new(),
        }
    }

    pub fn with_networks<S, I>(mut self, networks: I) -> Self
    where
        S: AsRef<str>,
        I: IntoIterator<Item = (u64, (S, Option<u64>))>,
    {
        for (id, (address, block_number)) in networks.into_iter() {
            self.networks
                .insert(id, (address.as_ref().to_string(), block_number));
        }
        self
    }

    fn bindings_path(&self, bindings_folder: &Path) -> PathBuf {
        bindings_folder.join(&self.name).with_extension("json")
    }

    pub fn generate<P: AsRef<Path>>(
        self,
        bindings_folder: P,
        all_derives: bool,
    ) -> anyhow::Result<proc_macro2::TokenStream> {
        let bindings_path = self.bindings_path(bindings_folder.as_ref());
        let mut macrogen = SolMacroGen::new(bindings_path, self.name.clone());
        generate_binding(&mut macrogen, all_derives)?;
        let mut expansion = macrogen
            .expansion
            .expect("if the expansion failed, it should have errored earlier");

        let module_name_ident = format_ident!("{}", self.name);
        let instance_name_ident = format_ident!("{}Instance", self.name);
        let instance = quote::quote! {
            pub type Instance = #module_name_ident :: #instance_name_ident<::alloy::providers::DynProvider>;
        };
        expansion.extend(instance);

        let no_networks = self.networks.is_empty();
        let networks = self.networks.into_iter().map(NetworkArm::from);
        let deployment_info = if no_networks {
            proc_macro2::TokenStream::new()
        } else {
            quote::quote! {
                use {
                    std::{
                        sync::LazyLock,
                        collections::HashMap
                    },
                    anyhow::{Result, Context},
                    alloy::{
                        providers::{Provider, DynProvider},
                        primitives::{address, Address},
                    },
                };

                pub const fn deployment_info(chain_id: u64) -> Option<(Address, Option<u64>)> {
                    match chain_id {
                        #( #networks ,)*
                        _ => None
                    }
                }

                /// Returns the contract's deployment address (if one exists) for the given chain.
                pub const fn deployment_address(chain_id: &u64) -> Option<::alloy::primitives::Address> {
                    match deployment_info(*chain_id) {
                        Some((address, _)) => Some(address),
                        None => None,
                    }
                }

                /// Returns the contract's deployment block (if one exists) for the given chain.
                pub const fn deployment_block(chain_id: &u64) -> Option<u64> {
                    match deployment_info(*chain_id) {
                        Some((_, block)) => block,
                        None => None,
                    }
                }

                impl Instance {
                    pub fn deployed(provider: &DynProvider) -> impl Future<Output = Result<Self>> + Send {
                        async move {
                            let chain_id = provider
                                .get_chain_id()
                                .await
                                .context("could not fetch current chain id")?;

                            let (address, _deployed_block) = deployment_info(chain_id)
                                .with_context(|| format!("no deployment info for chain {chain_id:?}"))?;

                            Ok(Instance::new(
                                address,
                                provider.clone(),
                            ))
                        }
                    }
                }
            }
        };
        expansion.extend(deployment_info);

        Ok(expansion)
    }

    pub fn write_formatted<P1, P2>(
        self,
        bindings_folder: P1,
        all_derives: bool,
        output_folder: P2,
    ) -> anyhow::Result<()>
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
    {
        let name = self.name.clone();
        let token_stream = self.generate(bindings_folder, all_derives)?;
        let mut buffer = String::new();
        write!(buffer, "{}", token_stream)?;
        let file: syn::File = syn::parse_file(&buffer)?;
        let formatted = prettyplease::unparse(&file);
        std::fs::write(
            output_folder.as_ref().join(name).with_extension("rs"),
            formatted,
        )?;
        Ok(())
    }
}

fn generate_binding(instance: &mut SolMacroGen, all_derives: bool) -> anyhow::Result<()> {
    let input = instance
        .get_sol_input()
        .map_err(|err| anyhow::anyhow!("{:?}", err))?
        .normalize_json()
        .map_err(|err| anyhow::anyhow!("{:?}", err))?;
    let SolInput {
        attrs: _,
        path: _,
        kind,
    } = input;

    let tokens = match kind {
        SolInputKind::Sol(mut file) => {
            let sol_attr: syn::Attribute = if all_derives {
                syn::parse_quote! {
                        #[sol(rpc, alloy_sol_types = alloy::sol_types, alloy_contract =
                alloy::contract, all_derives = true, extra_derives(serde::Serialize,
                serde::Deserialize))]     }
            } else {
                syn::parse_quote! {
                        #[sol(rpc, alloy_sol_types = alloy::sol_types, alloy_contract =
                alloy::contract)]     }
            };
            file.attrs.push(sol_attr);
            expand(file)?
        }
        _ => unreachable!(),
    };

    instance.expansion = Some(tokens);
    Ok(())
}

fn write_mod_name(contents: &mut String, name: &str) -> anyhow::Result<()> {
    if syn::parse_str::<syn::ItemMod>(&format!("pub mod {name};")).is_ok() {
        write!(contents, "pub mod {name};")?;
    } else {
        write!(contents, "pub mod r#{name};")?;
    }
    Ok(())
}

/// Wrapper to avoid destructuring the vector of tuples into three iterators.
///
/// The following code:
/// ```ignore
/// // We need to "destructure" the iterator into several due to
/// let chain_ids = self.networks.iter().map(|n| n.0);
/// let addresses = self.networks.iter().map(|n| n.1.0.clone());
/// let blocks = self.networks.iter().map(|n| match n.1.1 {
///     Some(block) => quote::quote! {Some (#block)},
///     None => quote::quote! {None},
/// });
/// // ...
/// quote::quote! {
///     pub const fn deployment_info(chain_id: u64) -> Option<(Address, Option<u64>)> {
///         match chain_id {
///             #(#chain_id => Some((::alloy::primitives::address!(#address), #block_number)),)*
///             _ => None
///         }
///     }
/// }
/// ```
///
/// Becomes:
/// ```ignore
/// let networks = self.networks.into_iter().map(NetworkArm::from);
/// // ...
/// quote::quote! {
///     pub const fn deployment_info(chain_id: u64) -> Option<(Address, Option<u64>)> {
///         match chain_id {
///             #( #networks ,)*
///             _ => None
///         }
///     }
/// }
/// ```
struct NetworkArm(u64, (String, Option<u64>));

impl ToTokens for NetworkArm {
    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
        let chain_id = self.0;
        let address = &self.1.0;
        let block_number = match self.1.1 {
            Some(block) => quote::quote! {Some (#block)},
            None => quote::quote! {None},
        };
        tokens.extend(quote::quote! {
           #chain_id => Some((::alloy::primitives::address!(#address), #block_number))
        });
    }
}

impl From<(u64, (String, Option<u64>))> for NetworkArm {
    fn from((chain_id, info): (u64, (String, Option<u64>))) -> Self {
        Self(chain_id, info)
    }
}

/// Declare a network tuple with an optional block number.
///
/// Example, without blocks:
/// ```no_run
/// # #[macro_use] extern crate contracts_generate;
/// # use contracts_generate::{MAINNET, SEPOLIA};
/// # fn main() {
/// # let _: [(_, (_, Option<u64>)); _] =
/// networks! {
///     MAINNET => "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
///     SEPOLIA => "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
/// };
/// # }
/// ```
///
/// Example, with blocks:
/// ```no_run
/// # #[macro_use] extern crate contracts_generate;
/// # use contracts_generate::{MAINNET, SEPOLIA};
/// # fn main() {
/// # let _: [(_, (_, Option<u64>)); _] =
/// networks! {
///     MAINNET => ("0x9008D19f58AAbD9eD0D60971565AA8510560ab41", 12593265),
///     SEPOLIA => ("0x9008D19f58AAbD9eD0D60971565AA8510560ab41", 4717488),
/// };
/// # }
/// ```
#[macro_export]
macro_rules! networks {
    // Entry point: accepts a list of entries and delegates to internal rules
    [$(
        $id:expr => $value:tt
    ),* $(,)?] => {
        [$(
            networks!(@entry $id => $value)
        ),*]
    };

    // Internal rule: handle entry with address and block (parenthesized)
    (@entry $id:expr => ($addr:expr, $block:expr)) => {
        ($id, ($addr, Some($block)))
    };

    // Internal rule: handle entry with just address
    (@entry $id:expr => $value:expr) => {
        ($id, ($value, None))
    };
}
