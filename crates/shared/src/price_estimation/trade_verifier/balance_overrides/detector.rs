use {
    super::Strategy,
    crate::code_simulation::{CodeSimulating, SimulationError},
    contracts::{dummy_contract, ERC20},
    ethcontract::{Address, H256, U256},
    ethrpc::extensions::StateOverride,
    maplit::hashmap,
    std::{
        collections::HashMap,
        fmt::{self, Debug, Formatter},
        sync::{Arc, LazyLock},
    },
    thiserror::Error,
    web3::{signing::keccak256, types::CallRequest},
};

/// A heuristic balance override detector based on `eth_call` simulations.
///
/// This has the exact same node requirements as trade verification.
#[derive(Clone)]
pub struct Detector {
    simulator: Arc<dyn CodeSimulating>,
}

impl Detector {
    /// Creates a new balance override detector.
    pub fn new(simulator: Arc<dyn CodeSimulating>) -> Self {
        Self { simulator }
    }

    /// Tries to detect the balance override strategy for the specified token.
    /// Returns an `Err` if it cannot detect the strategy or an internal
    /// simulation fails.
    pub async fn detect(&self, token: Address) -> Result<Strategy, DetectionError> {
        let token = dummy_contract!(ERC20, token);
        let call = CallRequest {
            to: Some(token.address()),
            data: token.methods().balance_of(*HOLDER).m.tx.data,
            ..Default::default()
        };
        let overrides = hashmap! {
            token.address() => StateOverride {
                state_diff: Some(STORAGE_OVERRIDES.clone()),
                ..Default::default()
            },
        };

        let output = self.simulator.simulate(call, overrides, None).await?;
        let balance = (output.len() == 32)
            .then(|| U256::from_big_endian(&output))
            .ok_or(DetectionError::Decode)?;

        TESTED_STRATEGIES
            .iter()
            .find_map(|helper| (helper.balance == balance).then_some(helper.strategy.clone()))
            .ok_or(DetectionError::NotFound)
    }
}

/// Contains all the information we need to determine which state override
/// was successful.
struct StrategyHelper {
    /// strategy that was used to compute the state override
    strategy: Strategy,
    /// balance amount the strategy wrote into the storage
    balance: U256,
}

impl StrategyHelper {
    fn new(strategy: Strategy, index: u8) -> Self {
        Self {
            strategy,
            // Use an exact value which isn't too large or too small. This helps
            // not have false positives for cases where the token balances in
            // some other denomination from the actual token balance (such as
            // stETH for example) and not run into issues with overflows.
            // We also make sure that we avoid 0 because `balanceOf()` returns
            // 0 by default so we can't use it to detect successful state overrides.
            balance: U256::from(u64::from_be_bytes([index + 1; 8])),
        }
    }
}

/// Storage slot based on OpenZeppelin's ERC20Upgradeable contract [^1].
///
/// [^1]: <https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L43-L44>
static OPEN_ZEPPELIN_ERC20_UPGRADEABLE: &str =
    "52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00";

/// Address which we try to override the balances for.
static HOLDER: LazyLock<Address> = LazyLock::new(|| {
    // On a technical note, Ethereum public addresses are, for the most
    // part, generated by taking the 20 last bytes of a Keccak-256 hash (for
    // things like contract creation, public address derivation from a
    // Secp256k1 public key, etc.), so we use one for our heuristics from a
    // 32-byte digest with no know pre-image, to prevent any weird
    // interactions with the weird tokens of the world.
    let mut address = Address::default();
    address.0.copy_from_slice(&keccak256(b"Moo!")[12..]);
    address.0[19] = address.0[19].wrapping_sub(1);
    address
});

/// All the strategies we use to detect where a token stores the balances.
static TESTED_STRATEGIES: LazyLock<Vec<StrategyHelper>> = LazyLock::new(|| {
    const FIRST_N_SLOTS: u8 = 25;

    // This is a pretty unsophisticated strategy where we basically try a
    // bunch of different slots and see which one sticks. We try balance
    // mappings for the first `TRIES` slots; each with a unique value.
    (0..FIRST_N_SLOTS).map(|i| {
        let strategy = Strategy::SolidityMapping { slot: U256::from(i) };
        StrategyHelper::new(strategy, i)
    })
    // Afterwards we try hardcoded storage slots based on popular utility
    // libraries like OpenZeppelin.
    .chain((FIRST_N_SLOTS..).zip([
        Strategy::SolidityMapping{ slot: U256::from(OPEN_ZEPPELIN_ERC20_UPGRADEABLE) },
        Strategy::SoladyMapping,
    ]).map(|(index, strategy)| {
        StrategyHelper::new(strategy, index)
    }))
    .collect()
});

/// Storage overrides (storage_slot, value) for all tested strategies.
static STORAGE_OVERRIDES: LazyLock<HashMap<H256, H256>> = LazyLock::new(|| {
    TESTED_STRATEGIES
        .iter()
        .map(|helper| helper.strategy.state_override(&HOLDER, &helper.balance))
        .collect::<HashMap<_, _>>()
});

impl Debug for Detector {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("Detector")
            .field("simulator", &format_args!("Arc<dyn CodeSimulating>"))
            .finish()
    }
}

/// An error detecting the balance override strategy for a token.
#[derive(Debug, Error)]
pub enum DetectionError {
    #[error("could not detect a balance override strategy")]
    NotFound,
    #[error("unable to decode simulation return data")]
    Decode,
    #[error(transparent)]
    Simulation(#[from] SimulationError),
}

#[cfg(test)]
mod tests {
    use {super::*, ethrpc::create_env_test_transport, web3::Web3};

    /// Tests that we can detect storage slots by probing the first
    /// n slots or by checking hardcoded known slots.
    /// Set `NODE_URL` environment to a mainnet RPC URL.
    #[ignore]
    #[tokio::test]
    async fn detects_storage_slots() {
        let detector = Detector {
            simulator: Arc::new(Web3::new(create_env_test_transport())),
        };

        let storage = detector
            .detect(addr!("c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::SolidityMapping { slot: 3.into() });

        let storage = detector
            .detect(addr!("4956b52ae2ff65d74ca2d61207523288e4528f96"))
            .await
            .unwrap();
        assert_eq!(
            storage,
            Strategy::SolidityMapping {
                slot: U256::from(OPEN_ZEPPELIN_ERC20_UPGRADEABLE),
            }
        );

        let storage = detector
            .detect(addr!("0000000000c5dc95539589fbd24be07c6c14eca4"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::SoladyMapping);
    }
}
