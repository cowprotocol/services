use {
    super::Strategy,
    crate::code_simulation::{CodeSimulating, SimulationError},
    contracts::{dummy_contract, ERC20},
    ethcontract::{Address, U256},
    ethrpc::extensions::StateOverride,
    maplit::hashmap,
    std::{
        fmt::{self, Debug, Formatter},
        sync::{Arc, LazyLock},
    },
    thiserror::Error,
    web3::{signing::keccak256, types::CallRequest},
};

/// A heuristic balance override detector based on `eth_call` simulations.
///
/// This has the exact same node requirements as trade verification.
#[derive(Clone)]
pub struct Detector {
    simulator: Arc<dyn CodeSimulating>,
}

/// Storage slot based on OpenZeppelin's ERC20Upgradeable contract [^1].
///
/// [^1]: <https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L43-L44>
static OPEN_ZEPPELIN_ERC20_UPGRADEABLE: LazyLock<U256> = LazyLock::new(|| {
    U256::from("52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00")
});

impl Detector {
    /// Number of different slots to try out.
    const TRIES: u8 = 25;

    /// Creates a new balance override detector.
    pub fn new(simulator: Arc<dyn CodeSimulating>) -> Self {
        Self { simulator }
    }

    /// Tries to detect the balance override strategy for the specified token.
    /// Returns an `Err` if it cannot detect the strategy or an internal
    /// simulation fails.
    pub async fn detect(&self, token: Address) -> Result<Strategy, DetectionError> {
        // Use an exact value which isn't too large or too small. This helps
        // not have false positives for cases where the token balances in
        // some other denomination from the actual token balance (such as
        // stETH for example) and not run into issues with overflows.
        // Also don't use 0 to avoid false postitive when trying to overwrite
        // a balance value of 0 which should always succeed.
        let marker_amount_for_index = |i| U256::from(u64::from_be_bytes([i + 1; 8]));

        // This is a pretty unsophisticated strategy where we basically try a
        // bunch of different slots and see which one sticks. We try balance
        // mappings for the first `TRIES` slots; each with a unique value.
        let mut tries = (0..Self::TRIES).map(|i| {
            let strategy = Strategy::Mapping { slot: U256::from(i) };
            (strategy, marker_amount_for_index(i))
        })
        // Afterwards we try hardcoded storage slots based on popular utility
        // libraries like OpenZeppelin.
        .chain((Self::TRIES..).zip([
            *OPEN_ZEPPELIN_ERC20_UPGRADEABLE,
        ]).map(|(index, slot)| {
            let strategy = Strategy::Mapping { slot };
            (strategy, marker_amount_for_index(index))
        }));

        // On a technical note, Ethereum public addresses are, for the most
        // part, generated by taking the 20 last bytes of a Keccak-256 hash (for
        // things like contract creation, public address derivation from a
        // Secp256k1 public key, etc.), so we use one for our heuristics from a
        // 32-byte digest with no know pre-image, to prevent any weird
        // interactions with the weird tokens of the world.
        let holder = {
            let mut address = Address::default();
            address.0.copy_from_slice(&keccak256(b"Moo!")[12..]);
            address.0[19] = address.0[19].wrapping_sub(1);
            address
        };

        let token = dummy_contract!(ERC20, token);
        let call = CallRequest {
            to: Some(token.address()),
            data: token.methods().balance_of(holder).m.tx.data,
            ..Default::default()
        };
        let overrides = hashmap! {
            token.address() => StateOverride {
                state_diff: Some(
                    tries
                        .clone()
                        .map(|(strategy, amount)| strategy.state_override(&holder, &amount))
                        .collect(),
                ),
                ..Default::default()
            },
        };

        let output = self.simulator.simulate(call, overrides, None).await?;
        let balance = (output.len() == 32)
            .then(|| U256::from_big_endian(&output))
            .ok_or(DetectionError::Decode)?;

        let strategy = tries
            .find_map(|(strategy, amount)| (amount == balance).then_some(strategy))
            .ok_or(DetectionError::NotFound)?;
        Ok(strategy)
    }
}

impl Debug for Detector {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("Detector")
            .field("simulator", &format_args!("Arc<dyn CodeSimulating>"))
            .finish()
    }
}

/// An error detecting the balance override strategy for a token.
#[derive(Debug, Error)]
pub enum DetectionError {
    #[error("could not detect a balance override strategy")]
    NotFound,
    #[error("unable to decode simulation return data")]
    Decode,
    #[error(transparent)]
    Simulation(#[from] SimulationError),
}

#[cfg(test)]
mod tests {
    use {super::*, ethrpc::create_env_test_transport, web3::Web3};

    /// Tests that we can detect storage slots by probing the first
    /// n slots or by checking hardcoded known slots.
    /// Set `NODE_URL` environment to a mainnet RPC URL.
    #[ignore]
    #[tokio::test]
    async fn detects_storage_slots() {
        let detector = Detector {
            simulator: Arc::new(Web3::new(create_env_test_transport())),
        };

        let storage = detector
            .detect(addr!("c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::Mapping { slot: 3.into() });

        let storage = detector
            .detect(addr!("4956b52ae2ff65d74ca2d61207523288e4528f96"))
            .await
            .unwrap();
        assert_eq!(
            storage,
            Strategy::Mapping {
                slot: *OPEN_ZEPPELIN_ERC20_UPGRADEABLE
            }
        );
    }
}
