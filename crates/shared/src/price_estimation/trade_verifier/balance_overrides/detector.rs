use {
    super::Strategy,
    crate::code_simulation::{CodeSimulating, SimulationError},
    contracts::{dummy_contract, ERC20},
    ethcontract::{Address, U256},
    ethrpc::extensions::StateOverride,
    maplit::hashmap,
    std::sync::Arc,
    thiserror::Error,
    web3::{signing::keccak256, types::CallRequest},
};

/// A heuristic balance override detector based on `eth_call` simulations.
///
/// This has the exact same node requirements as trade verification.
pub struct Detector {
    simulator: Arc<dyn CodeSimulating>,
}

#[allow(dead_code)]
impl Detector {
    /// Number of different slots to try out.
    const TRIES: u8 = 25;

    /// Creates a new balance override detector.
    pub fn new(simulator: Arc<dyn CodeSimulating>) -> Self {
        Self { simulator }
    }

    /// Tries to detect the balance override strategy for the specified token.
    /// Returning `None` if it cannot detect the strategy, or an error if an
    /// internal simulation fails.
    pub async fn detect(&self, token: Address) -> Result<Strategy, DetectionError> {
        // This is a pretty unsophisticated strategy where we basically try a
        // bunch of different slots and see which one sticks. We try balance
        // mappings for the first `TRIES` slots; each with a unique value.
        let mut tries = (0..Self::TRIES).map(|i| {
            let strategy = Strategy::Mapping {
                slot: U256::from(i),
            };
            // Use an exact value which isn't too large or too small. This helps
            // not have false positives for cases where the token balances in
            // some other denomination from the actual token balance (such as
            // stETH for example) and not run into issues with overflows.
            let amount = U256::from(u64::from_be_bytes([i; 8]));

            (strategy, amount)
        });

        // On a technical note, Ethereum public addresses are, for the most
        // part, generated by taking the 20 last bytes of a Keccak-256 hash (for
        // things like contract creation, public address derivation from a
        // Secp256k1 public key, etc.), so we use one for our heuristics from a
        // 32-byte digest with no know pre-image, to prevent any weird
        // interactions with the weird tokens of the world.
        let holder = {
            let mut address = Address::default();
            address.0.copy_from_slice(&keccak256(b"Moo!")[12..]);
            address.0[19] = address.0[19].wrapping_sub(1);
            address
        };

        let token = dummy_contract!(ERC20, token);
        let call = CallRequest {
            to: Some(token.address()),
            data: token.methods().balance_of(holder).m.tx.data,
            ..Default::default()
        };
        let overrides = hashmap! {
            token.address() => StateOverride {
                state_diff: Some(
                    tries
                        .clone()
                        .map(|(strategy, amount)| strategy.state_override(&holder, &amount))
                        .collect(),
                ),
                ..Default::default()
            },
        };

        let output = self.simulator.simulate(call, overrides, None).await?;
        let balance = (output.len() == 32)
            .then(|| U256::from_big_endian(&output))
            .ok_or(DetectionError::Decode)?;

        let strategy = tries
            .find_map(|(strategy, amount)| (amount == balance).then_some(strategy))
            .ok_or(DetectionError::NotFound)?;
        Ok(strategy)
    }
}

/// An error detecting the balance override strategy for a token.
#[derive(Debug, Error)]
pub enum DetectionError {
    #[error("could not detect a balance override strategy")]
    NotFound,
    #[error("unable to decode simulation return data")]
    Decode,
    #[error(transparent)]
    Simulation(#[from] SimulationError),
}
