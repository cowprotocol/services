use {
    super::Strategy,
    crate::code_simulation::{CodeSimulating, SimulationError},
    contracts::{dummy_contract, ERC20},
    ethcontract::{Address, H256, U256},
    ethrpc::extensions::StateOverride,
    maplit::hashmap,
    std::{
        collections::HashMap,
        fmt::{self, Debug, Formatter},
        sync::Arc,
    },
    thiserror::Error,
    web3::{signing::keccak256, types::CallRequest},
};

/// A heuristic balance override detector based on `eth_call` simulations.
///
/// This has the exact same node requirements as trade verification.
#[derive(Clone)]
pub struct Detector(Arc<Inner>);

pub struct Inner {
    simulator: Arc<dyn CodeSimulating>,
    /// address that we try to override the balances for
    holder: Address,
    /// all strategies used to detect successful balance overrides
    strategies: Vec<StrategyHelper>,
    /// overrides for all tested strategies
    state_overrides: HashMap<H256, H256>,
}

impl std::ops::Deref for Detector {
    type Target = Inner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Detector {
    /// Creates a new balance override detector.
    pub fn new(simulator: Arc<dyn CodeSimulating>, probing_depth: u8) -> Self {
        let holder = {
            // On a technical note, Ethereum public addresses are, for the most
            // part, generated by taking the 20 last bytes of a Keccak-256 hash (for
            // things like contract creation, public address derivation from a
            // Secp256k1 public key, etc.), so we use one for our heuristics from a
            // 32-byte digest with no know pre-image, to prevent any weird
            // interactions with the weird tokens of the world.
            let mut address = Address::default();
            address.0.copy_from_slice(&keccak256(b"Moo!")[12..]);
            address.0[19] = address.0[19].wrapping_sub(1);
            address
        };

        let strategies: Vec<_> = {
            // First test storage slots that don't need guesswork.
            let mut strategies = vec![
                Strategy::SoladyMapping,
                Strategy::SolidityMapping {
                    slot: U256::from(OPEN_ZEPPELIN_ERC20_UPGRADEABLE),
                },
            ];

            // For each entry point probe the first n following slots.
            let entry_points = [
                // solc lays out memory linearly starting at 0 by default
                "0000000000000000000000000000000000000000000000000000000000000000",
            ];
            for start_slot in entry_points {
                let mut slot = U256::from(start_slot);
                for _ in 0..probing_depth {
                    strategies.push(Strategy::SolidityMapping { slot });
                    slot += U256::one();
                }
            }

            strategies
                .into_iter()
                .enumerate()
                .map(|(index, strategy)| StrategyHelper::new(strategy, index))
                .collect()
        };

        let state_overrides = strategies
            .iter()
            .map(|helper| helper.strategy.state_override(&holder, &helper.balance))
            .collect::<HashMap<_, _>>();

        Self(Arc::new(Inner {
            simulator,
            holder,
            strategies,
            state_overrides,
        }))
    }

    /// Tries to detect the balance override strategy for the specified token.
    /// Returns an `Err` if it cannot detect the strategy or an internal
    /// simulation fails.
    pub async fn detect(&self, token: Address) -> Result<Strategy, DetectionError> {
        let token = dummy_contract!(ERC20, token);
        let call = CallRequest {
            to: Some(token.address()),
            data: token.methods().balance_of(self.holder).m.tx.data,
            ..Default::default()
        };
        let overrides = hashmap! {
            token.address() => StateOverride {
                state_diff: Some(self.state_overrides.clone()),
                ..Default::default()
            },
        };

        let output = self.simulator.simulate(call, overrides, None).await?;
        let balance = (output.len() == 32)
            .then(|| U256::from_big_endian(&output))
            .ok_or(DetectionError::Decode)?;

        self.strategies
            .iter()
            .find_map(|helper| (helper.balance == balance).then_some(helper.strategy.clone()))
            .ok_or(DetectionError::NotFound)
    }
}

/// Contains all the information we need to determine which state override
/// was successful.
struct StrategyHelper {
    /// strategy that was used to compute the state override
    strategy: Strategy,
    /// balance amount the strategy wrote into the storage
    balance: U256,
}

impl StrategyHelper {
    fn new(strategy: Strategy, index: usize) -> Self {
        let index = u8::try_from(index).expect("unreasonable amount of strategies used");
        Self {
            strategy,
            // Use an exact value which isn't too large or too small. This helps
            // not have false positives for cases where the token balances in
            // some other denomination from the actual token balance (such as
            // stETH for example) and not run into issues with overflows.
            // We also make sure that we avoid 0 because `balanceOf()` returns
            // 0 by default so we can't use it to detect successful state overrides.
            balance: U256::from(u64::from_be_bytes([index + 1; 8])),
        }
    }
}

// <https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L43-L44>
const OPEN_ZEPPELIN_ERC20_UPGRADEABLE: &str =
    "52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00";

impl Debug for Detector {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("Detector")
            .field("simulator", &format_args!("Arc<dyn CodeSimulating>"))
            .finish()
    }
}

/// An error detecting the balance override strategy for a token.
#[derive(Debug, Error)]
pub enum DetectionError {
    #[error("could not detect a balance override strategy")]
    NotFound,
    #[error("unable to decode simulation return data")]
    Decode,
    #[error(transparent)]
    Simulation(#[from] SimulationError),
}

#[cfg(test)]
mod tests {
    use {super::*, ethrpc::create_env_test_transport, web3::Web3};

    /// Tests that we can detect storage slots by probing the first
    /// n slots or by checking hardcoded known slots.
    /// Set `NODE_URL` environment to a mainnet RPC URL.
    #[ignore]
    #[tokio::test]
    async fn detects_storage_slots_mainnet() {
        let detector = Detector::new(Arc::new(Web3::new(create_env_test_transport())), 60);

        let storage = detector
            .detect(addr!("c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::SolidityMapping { slot: 3.into() });

        let storage = detector
            .detect(addr!("4956b52ae2ff65d74ca2d61207523288e4528f96"))
            .await
            .unwrap();
        assert_eq!(
            storage,
            Strategy::SolidityMapping {
                slot: U256::from(OPEN_ZEPPELIN_ERC20_UPGRADEABLE),
            }
        );

        let storage = detector
            .detect(addr!("0000000000c5dc95539589fbd24be07c6c14eca4"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::SoladyMapping);
    }

    /// Tests that we can detect storage slots by probing the first
    /// n slots or by checking hardcoded known slots.
    /// Set `NODE_URL` environment to an arbitrum RPC URL.
    #[ignore]
    #[tokio::test]
    async fn detects_storage_slots_arbitrum() {
        let detector = Detector::new(Arc::new(Web3::new(create_env_test_transport())), 60);

        // all bridged tokens on arbitrum require a ton of probing
        let storage = detector
            .detect(addr!("ff970a61a04b1ca14834a43f5de4533ebddb5cc8"))
            .await
            .unwrap();
        assert_eq!(storage, Strategy::SolidityMapping { slot: 51.into() });
    }
}
